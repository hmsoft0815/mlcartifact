// Copyright (c) 2026 Michael Lechner. All rights reserved.
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"log/slog"
	"net"
	"net/http"
	"os"

	"github.com/hmsoft0815/mlcartifact/cmd/server/internal/grpc"
	"github.com/hmsoft0815/mlcartifact/cmd/server/internal/handlers"
	"github.com/hmsoft0815/mlcartifact/cmd/server/internal/storage"
	pb "github.com/hmsoft0815/mlcartifact/proto"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
	googlegrpc "google.golang.org/grpc"
)

const (
	version = "1.2.0"
	name    = "artifact-server"
)

func getTools() []mcp.Tool {
	return []mcp.Tool{
		mcp.NewTool(
			"write_artifact",
			mcp.WithDescription(`Saves a generated file (like a converted Markdown, a report, or a code snippet) to a secure artifact storage.
This tool returns a JSON object containing the 'id', 'filename', and 'expires_at' (ISO timestamp) of the saved artifact.
YOU MUST include the specialized <file id="...">filename</file> tag in your final response to the user so they can access the file.`),
			mcp.WithString("filename",
				mcp.Required(),
				mcp.Description("The desired name for the file (e.g., 'converted_doc.md')."),
			),
			mcp.WithString("content",
				mcp.Required(),
				mcp.Description("The full text content to be saved."),
			),
			mcp.WithString("mime_type",
				mcp.Description("Optional: The MIME type of the content (e.g. 'text/markdown', 'text/csv'). If omitted, it will be detected from the filename."),
			),
			mcp.WithNumber("expires_in_hours",
				mcp.Description("Optional: Hours after which the file should be deleted (default 24)."),
			),
		),
		mcp.NewTool(
			"read_artifact",
			mcp.WithDescription("Retrieves the content of a saved artifact. Use this to read data generated by other tools."),
			mcp.WithString("id", mcp.Required(), mcp.Description("The unique artifact ID or sanitized filename.")),
			mcp.WithString("user_id", mcp.Description("Optional: The user ID to scope the lookup.")),
		),
		mcp.NewTool(
			"list_artifacts",
			mcp.WithDescription("Lists all saved artifacts for a user or in the global scope."),
			mcp.WithString("user_id", mcp.Description("Optional: The user ID to scope the listing.")),
		),
		mcp.NewTool(
			"delete_artifact",
			mcp.WithDescription("Permanently deletes an artifact from the storage."),
			mcp.WithString("id", mcp.Required(), mcp.Description("The unique artifact ID or sanitized filename.")),
			mcp.WithString("user_id", mcp.Description("Optional: The user ID to scope the deletion.")),
		),
	}
}

func main() {
	dump := flag.Bool("dump", false, "Dump available tools as JSON and exit")
	v := flag.Bool("version", false, "Print version and exit")
	addr := flag.String("addr", "", "Listen address for SSE (e.g. ':8080'). If empty, uses stdio.")
	grpcAddr := flag.String("grpc-addr", ":9590", "Listen address for gRPC service")
	mcpLimit := flag.Int("mcp-list-limit", 100, "Max artifacts to return in MCP list_artifacts")
	dataDir := flag.String("data-dir", ".artifacts", "Base directory for artifact storage")
	flag.Parse()

	if *v {
		fmt.Printf("%s version: %s\n", name, version)
		return
	}

	// Initialize store and set in handlers
	store := storage.NewStore(*dataDir)
	slog.Info("initializing artifact store", "dir", *dataDir)
	handlers.SetStore(store)
	handlers.SetMCPListLimit(*mcpLimit)

	if *dump {
		tools := getTools()
		b, _ := json.MarshalIndent(tools, "", "  ")
		fmt.Println(string(b))
		return
	}

	mcpServer := server.NewMCPServer(
		name,
		version,
		server.WithToolCapabilities(false),
	)

	// Add tools
	for _, t := range getTools() {
		switch t.Name {
		case "write_artifact":
			mcpServer.AddTool(t, handlers.WriteArtifact)
		case "read_artifact":
			mcpServer.AddTool(t, handlers.ReadArtifact)
		case "list_artifacts":
			mcpServer.AddTool(t, handlers.ListArtifacts)
		case "delete_artifact":
			mcpServer.AddTool(t, handlers.DeleteArtifact)
		}
	}

	// Start gRPC server in background
	go func() {
		lis, err := net.Listen("tcp", *grpcAddr)
		if err != nil {
			slog.Error("gRPC net.Listen failed", "err", err)
			return
		}

		grpcServer := googlegrpc.NewServer()
		pb.RegisterArtifactServiceServer(grpcServer, grpc.NewServer(store))

		slog.Info("gRPC server started", "addr", *grpcAddr)
		if err := grpcServer.Serve(lis); err != nil {
			slog.Error("gRPC server failed", "err", err)
		}
	}()

	if *addr != "" {
		// SSE Mode
		sse := server.NewSSEServer(mcpServer, server.WithBaseURL(fmt.Sprintf("http://localhost%s", *addr)))
		slog.Info("SSE server started", "addr", *addr, "name", name)
		if err := http.ListenAndServe(*addr, sse); err != nil {
			slog.Error("http server failed", "err", err)
			os.Exit(1)
		}
	} else {
		// Stdio Mode
		slog.Info("stdio server started", "name", name, "version", version)
		if err := server.ServeStdio(mcpServer); err != nil {
			slog.Error("fatal error", "err", err)
			os.Exit(1)
		}
	}
}
